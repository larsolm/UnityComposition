[#topics/variables-8]

## Custom Variable Stores

When writing https://docs.unity3d.com/Manual/CreatingComponents.html[custom components^] it is often useful to expose the object and its properties to the variables system. This can be done by implementing the <<reference/i-variable-store.html,IVariableStore>> interface. This interface is fairly straight forward and is perfect for small helper classes that expose a few properties. For example, consider an inventory item that consists of an object and count:

[source,cs]
----
using PiRhoSoft.CompositionEngine
using UnityEngine;

namespace PiRhoSoft.CompositionExample
{
	public class InventoryItem : IVariableStore
	{
		public Item Item;
		public int Count;
		
		private static readonly string[] _names = new string[] { nameof(Item), nameof(Count) };

		public IList<string> GetVariableNames() => _names;
		public VariableValue GetVariable(string name)
		{
			switch (name)
			{
				case nameof(Item): return VariableValue.Create(Item);
				case nameof(Count): return VariableValue.Create(Count);
				default: return VariableValue.Empty;
			}
		}

		public SetVariableResult SetVariable(string name, VariableValue value)
		{
			switch (name)
			{
				case nameof(Item): return SetVariableResult.ReadOnly;
				case nameof(Count):
					if (value.TryGetInt(out int count))
					{
						Count = count;
						return SetVariableResult.Success;
					}
					else
					{
						return SetVariableResult.TypeMismatch;
					}
				default: return SetVariableResult.NotFound;
			}
		}
	}
}
----

For more complex classes with many properties, or classes that want a mix of code defined and editor defined properties, it is much simpler and more flexible to use the <<reference,mapped-variable-store,MappedVariableStore>> class. This can be used directly or by deriving from the <<reference/variable-set-component.html,VariableSetComponent>> (for https://docs.unity3d.com/ScriptReference/MonoBehaviour.html[MonoBehaviours^]) or <<reference/variable-set-asset.html,VariableSetAsset>> (for https://docs.unity3d.com/ScriptReference/ScriptableObject.html[ScriptableObjects^]). These classes can also be used directly without subclassing as described in <<topics/variables-3.html,Defining Variables>> but become more powerful when extended. Deriving automatically adds <<reference/variable-schema.html,VariableSchema>> support, <<reference/i-variable-store.html,IVariableStore>> access for all schema and code defined properties, variable resetting with <<reference/i-variable-reset.html,IVariableReset>>, and full editor and <<topics/graphs-5.html,watch window>> integration.

To expose code defined fields and properties to the variables system, the <<reference/mapped-variable-attribute,MappedVariableAttribute>> is used. This is as simple as adding the attribute to a field or property on a class derived from <<reference/variable-set-component.html,VariableSetComponent>> or <<reference/variable-set-asset.html,VariableSetAsset>>. The <<reference/mapped-variable-attribute,MappedVariableAttribute>> can optionally be passed two parameters indicating whether the variable is allowed to be read and written by the variables system. A property without a setter will automatically be read only.

[source,cs]
----
using PiRhoSoft.CompositionEngine
using UnityEngine;

namespace PiRhoSoft.CompositionExample
{
	public class Player : VariableSetComponent
	{
		[MappedVariable] public string Name;
	}
}
----

If this player is placed on the global store (possibly using <<reference/variable-link.html,VariableLink>>) with the name `"Player"`, _Name_ could then be accessed with a <<reference/variable-reference.html,VariableReference>> set to `global.Player.Name`.

All <<reference/variable-type.html,VariableTypes>> are supported with <<reference/mapped-variable-attribute,MappedVariableAttribute>> including https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.ilist-1?view=netframework-4.8[IList<T>^] implementors when _T_ is itself a valid <<reference/variable-type.html,VariableType>>. Here is a slightly expanded example of Player using the InventoryItem class defined above and some `PlayerClass` implemented elsewhere that maybe defines some attributes or capabilities of the player:

[source,cs]
----
using PiRhoSoft.CompositionEngine
using UnityEngine;

namespace PiRhoSoft.CompositionExample
{
	public class Player : VariableSetComponent
	{
		[MappedVariable] public string Name;
		[MappedVariable(true, false)] public List<InventoryItem> Inventory = new List<InventoryItem>();

		[SerializeField] private PlayerClass _class;
		
		[MappedVariable] public PlayerClass Class
		{
			get => _class;
			set => SetClass(value);
		}

		private void SetClass(PlayerClass c)
		{
			_class = c;
			// ...
		}
	}
}
----

Items in the Player`s inventory can now be accessed with `global.Player.Inventory`. Getting the `Count` of the first item would be done using `global.Player.Inventory[0].Count`. Note that _Inventory_ is marked as not writable meaning the statement `global.Player.Inventory = somethingElse` would fail, however items can still be added and removed. The `Class` of `Player` is exposed as a property allowing the code to perform any necessary updates when it is changed.

### Exposing Third Party Classes

In situations where an https://docs.unity3d.com/ScriptReference/Object.html[Object^] class cannot be changed to implement <<reference/i-variable-store.html,IVariableStore>>, like for a third party or built in https://docs.unity3d.com/ScriptReference/Component.html[Component^], the <<reference/class-map-1.html,ClassMap>> class is provided. By deriving from this class and registering an instance with <<reference/class-map.html,ClassMap>> properties can be exposed to the variables system, making them available in <<topics/variables-4.html,VariableReferences and Expressions>>. The following is an example of the `InventoryXtem` class defined using a <<reference/class-map.html,ClassMap>> instead of with <<reference/i-variable-store.html,IVariableStore>>.

[source,cs]
----
using PiRhoSoft.CompositionEngine
using UnityEngine;

namespace PiRhoSoft.CompositionExample
{
	public class InventoryItem
	{
		public Item Item;
		public int Count;

		[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.AfterAssembliesLoaded)]
		private static void RegisterMap()
		{
			ClassMap.Add(new InventoryItemMap());
		}
	}

	public class InventoryItemMap : ClassMap<InventoryItem>
	{
		private static List<string> _names = new List<string>
		{
			nameof(InventoryItem.Item),
			nameof(InventoryItem.Count)
		};

		public override IList<string> GetVariableNames()
		{
			return _names;
		}

		public override VariableValue GetVariable(InventoryItem obj, string name)
		{
			switch (name)
			{
				case nameof(InventoryItem.Item): return VariableValue.Create(obj.Item);
				case nameof(InventoryItem.Count): return VariableValue.Create(obj.Count);
			}

			return VariableValue.Empty;
		}

		public override SetVariableResult SetVariable(InventoryItem obj, string name, VariableValue value)
		{
			switch (name)
			{
				case nameof(InventoryItem.Item): if (value.TryGetReference<Item>(out var item)) { obj.Item = item; return SetVariableResult.Success; } return SetVariableResult.TypeMismatch;
				case nameof(InventoryItem.Count): if (value.TryGetInt(out var count)) { obj.Count = count; return SetVariableResult.Success; } return SetVariableResult.TypeMismatch;
			}

			return SetVariableResult.NotFound;
		}
	}
}
----
